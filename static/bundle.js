/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(1);\nmodule.exports = __webpack_require__(1);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n__webpack_require__(2);\n\n__webpack_require__(6);\n\nvar _virtualElement = __webpack_require__(7);\n\nvar _virtualElement2 = _interopRequireDefault(_virtualElement);\n\nvar _deku = __webpack_require__(11);\n\nvar _stores = __webpack_require__(40);\n\nvar _upcomingGames = __webpack_require__(41);\n\n(0, _upcomingGames.showEvents)();\n(0, _upcomingGames.loadGames)();\n\nvar TeamSelector = {\n  render: function render(_ref) {\n    var props = _ref.props;\n    var state = _ref.state;\n\n    return (0, _virtualElement2['default'])(\n      'h1',\n      null,\n      'Upcoming Games'\n    );\n  }\n};\n\nvar UpcomingGame = {\n  render: function render(_ref2) {\n    var props = _ref2.props;\n    var state = _ref2.state;\n    var team = props.team;\n    var game = props.game;\n\n    function remove() {\n      _stores.teamStore.dispatch({ type: 'REMOVE', team: team });\n    }\n\n    return (0, _virtualElement2['default'])(\n      'div',\n      { id: 'UpcomingGame-' + team.id, 'class': 'upcoming-game' },\n      (0, _virtualElement2['default'])(\n        'div',\n        { 'class': 'upcoming-game--team' },\n        (0, _virtualElement2['default'])('img', { src: team.images['40'], width: '40', height: '40' }),\n        (0, _virtualElement2['default'])(\n          'h3',\n          { title: team.event.name },\n          team.name\n        ),\n        (0, _virtualElement2['default'])(\n          'button',\n          { onClick: remove },\n          'Remove'\n        )\n      )\n    );\n  }\n};\n\nvar UpcomingGames = {\n  render: function render(_ref3) {\n    var props = _ref3.props;\n    var state = _ref3.state;\n    var teams = props.teams;\n    var games = props.games;\n\n    var _games = _toArray(games);\n\n    var game = _games[0];\n\n    var otherGames = _games.slice(1);\n\n    var gameInfo = undefined;\n    if (game) {\n      gameInfo = (0, _virtualElement2['default'])(\n        'p',\n        null,\n        'Your next game is on ',\n        game.start_date,\n        ' at ',\n        game.start_time,\n        ' on field ',\n        game.field_id,\n        ' ',\n        game.field_number\n      );\n    }\n    return (0, _virtualElement2['default'])(\n      'div',\n      null,\n      gameInfo,\n      (0, _virtualElement2['default'])(\n        'p',\n        null,\n        'You have ',\n        teams.length,\n        ' teams selected.'\n      ),\n      teams.map(function (team) {\n        return (0, _virtualElement2['default'])(UpcomingGame, { team: team });\n      })\n    );\n  }\n};\n\nvar App = {\n  propTypes: {\n    games: { source: 'games' },\n    teams: { source: 'teams' }\n  },\n  render: function render(_ref4) {\n    var props = _ref4.props;\n    var state = _ref4.state;\n\n    return (0, _virtualElement2['default'])(\n      'div',\n      null,\n      (0, _virtualElement2['default'])(TeamSelector, null),\n      (0, _virtualElement2['default'])(UpcomingGames, { teams: props.teams, games: props.games })\n    );\n  }\n};\n\nvar app = (0, _deku.tree)((0, _virtualElement2['default'])(App, null));\n\napp.use(_stores.teamStore.plugin);\napp.use(_stores.gameStore.plugin);\n\n(0, _deku.render)(app, document.getElementById('app'));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./index.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n'use strict';\n\n(function () {\n  \"use strict\";\n  function lib$es6$promise$utils$$objectOrFunction(x) {\n    return typeof x === 'function' || typeof x === 'object' && x !== null;\n  }\n\n  function lib$es6$promise$utils$$isFunction(x) {\n    return typeof x === 'function';\n  }\n\n  function lib$es6$promise$utils$$isMaybeThenable(x) {\n    return typeof x === 'object' && x !== null;\n  }\n\n  var lib$es6$promise$utils$$_isArray;\n  if (!Array.isArray) {\n    lib$es6$promise$utils$$_isArray = function (x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    };\n  } else {\n    lib$es6$promise$utils$$_isArray = Array.isArray;\n  }\n\n  var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n  var lib$es6$promise$asap$$len = 0;\n  var lib$es6$promise$asap$$toString = ({}).toString;\n  var lib$es6$promise$asap$$vertxNext;\n  var lib$es6$promise$asap$$customSchedulerFn;\n\n  var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n    lib$es6$promise$asap$$len += 2;\n    if (lib$es6$promise$asap$$len === 2) {\n      // If len is 2, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      if (lib$es6$promise$asap$$customSchedulerFn) {\n        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n      } else {\n        lib$es6$promise$asap$$scheduleFlush();\n      }\n    }\n  };\n\n  function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n    lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n  }\n\n  function lib$es6$promise$asap$$setAsap(asapFn) {\n    lib$es6$promise$asap$$asap = asapFn;\n  }\n\n  var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;\n  var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n  var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n  var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n  // test for web worker but not in IE10\n  var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n  // node\n  function lib$es6$promise$asap$$useNextTick() {\n    // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // see https://github.com/cujojs/when/issues/410 for details\n    return function () {\n      process.nextTick(lib$es6$promise$asap$$flush);\n    };\n  }\n\n  // vertx\n  function lib$es6$promise$asap$$useVertxTimer() {\n    return function () {\n      lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n    };\n  }\n\n  function lib$es6$promise$asap$$useMutationObserver() {\n    var iterations = 0;\n    var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n    var node = document.createTextNode('');\n    observer.observe(node, { characterData: true });\n\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  }\n\n  // web worker\n  function lib$es6$promise$asap$$useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = lib$es6$promise$asap$$flush;\n    return function () {\n      channel.port2.postMessage(0);\n    };\n  }\n\n  function lib$es6$promise$asap$$useSetTimeout() {\n    return function () {\n      setTimeout(lib$es6$promise$asap$$flush, 1);\n    };\n  }\n\n  var lib$es6$promise$asap$$queue = new Array(1000);\n  function lib$es6$promise$asap$$flush() {\n    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {\n      var callback = lib$es6$promise$asap$$queue[i];\n      var arg = lib$es6$promise$asap$$queue[i + 1];\n\n      callback(arg);\n\n      lib$es6$promise$asap$$queue[i] = undefined;\n      lib$es6$promise$asap$$queue[i + 1] = undefined;\n    }\n\n    lib$es6$promise$asap$$len = 0;\n  }\n\n  function lib$es6$promise$asap$$attemptVertx() {\n    try {\n      var r = require;\n      var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"vertx\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n      lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return lib$es6$promise$asap$$useVertxTimer();\n    } catch (e) {\n      return lib$es6$promise$asap$$useSetTimeout();\n    }\n  }\n\n  var lib$es6$promise$asap$$scheduleFlush;\n  // Decide what async method to use to triggering processing of queued callbacks:\n  if (lib$es6$promise$asap$$isNode) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n  } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n  } else if (lib$es6$promise$asap$$isWorker) {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n  } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n  } else {\n    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n  }\n\n  function lib$es6$promise$$internal$$noop() {}\n\n  var lib$es6$promise$$internal$$PENDING = void 0;\n  var lib$es6$promise$$internal$$FULFILLED = 1;\n  var lib$es6$promise$$internal$$REJECTED = 2;\n\n  var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$selfFulfillment() {\n    return new TypeError(\"You cannot resolve a promise with itself\");\n  }\n\n  function lib$es6$promise$$internal$$cannotReturnOwn() {\n    return new TypeError('A promises callback cannot return that same promise.');\n  }\n\n  function lib$es6$promise$$internal$$getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n      return lib$es6$promise$$internal$$GET_THEN_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n    lib$es6$promise$asap$$asap(function (promise) {\n      var sealed = false;\n      var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n        if (thenable !== value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n      if (!sealed && error) {\n        sealed = true;\n        lib$es6$promise$$internal$$reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n      lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n      lib$es6$promise$$internal$$reject(promise, thenable._result);\n    } else {\n      lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function (reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    }\n  }\n\n  function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n    if (maybeThenable.constructor === promise.constructor) {\n      lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n    } else {\n      var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n      if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n      } else if (then === undefined) {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      } else if (lib$es6$promise$utils$$isFunction(then)) {\n        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function lib$es6$promise$$internal$$resolve(promise, value) {\n    if (promise === value) {\n      lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n      lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n    } else {\n      lib$es6$promise$$internal$$fulfill(promise, value);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publishRejection(promise) {\n    if (promise._onerror) {\n      promise._onerror(promise._result);\n    }\n\n    lib$es6$promise$$internal$$publish(promise);\n  }\n\n  function lib$es6$promise$$internal$$fulfill(promise, value) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n    if (promise._subscribers.length !== 0) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n    }\n  }\n\n  function lib$es6$promise$$internal$$reject(promise, reason) {\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      return;\n    }\n    promise._state = lib$es6$promise$$internal$$REJECTED;\n    promise._result = reason;\n\n    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n  }\n\n  function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n    var subscribers = parent._subscribers;\n    var length = subscribers.length;\n\n    parent._onerror = null;\n\n    subscribers[length] = child;\n    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n    }\n  }\n\n  function lib$es6$promise$$internal$$publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child,\n        callback,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function lib$es6$promise$$internal$$ErrorObject() {\n    this.error = null;\n  }\n\n  var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n  function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n      return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n    }\n  }\n\n  function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n        value,\n        error,\n        succeeded,\n        failed;\n\n    if (hasCallback) {\n      value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n      if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n      // noop\n    } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n  }\n\n  function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n    try {\n      resolver(function resolvePromise(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }, function rejectPromise(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      });\n    } catch (e) {\n      lib$es6$promise$$internal$$reject(promise, e);\n    }\n  }\n\n  function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n    var enumerator = this;\n\n    enumerator._instanceConstructor = Constructor;\n    enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (enumerator._validateInput(input)) {\n      enumerator._input = input;\n      enumerator.length = input.length;\n      enumerator._remaining = input.length;\n\n      enumerator._init();\n\n      if (enumerator.length === 0) {\n        lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n      } else {\n        enumerator.length = enumerator.length || 0;\n        enumerator._enumerate();\n        if (enumerator._remaining === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        }\n      }\n    } else {\n      lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n    }\n  }\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function (input) {\n    return lib$es6$promise$utils$$isArray(input);\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {\n    return new Error('Array Methods must be provided an Array');\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._init = function () {\n    this._result = new Array(this.length);\n  };\n\n  var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {\n    var enumerator = this;\n\n    var length = enumerator.length;\n    var promise = enumerator.promise;\n    var input = enumerator._input;\n\n    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      enumerator._eachEntry(input[i], i);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {\n    var enumerator = this;\n    var c = enumerator._instanceConstructor;\n\n    if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n      if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n        entry._onerror = null;\n        enumerator._settledAt(entry._state, i, entry._result);\n      } else {\n        enumerator._willSettleAt(c.resolve(entry), i);\n      }\n    } else {\n      enumerator._remaining--;\n      enumerator._result[i] = entry;\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {\n    var enumerator = this;\n    var promise = enumerator.promise;\n\n    if (promise._state === lib$es6$promise$$internal$$PENDING) {\n      enumerator._remaining--;\n\n      if (state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      } else {\n        enumerator._result[i] = value;\n      }\n    }\n\n    if (enumerator._remaining === 0) {\n      lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n    }\n  };\n\n  lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {\n    var enumerator = this;\n\n    lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {\n      enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n    }, function (reason) {\n      enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n    });\n  };\n  function lib$es6$promise$promise$all$$all(entries) {\n    return new lib$es6$promise$enumerator$$default(this, entries).promise;\n  }\n  var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n  function lib$es6$promise$promise$race$$race(entries) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n    if (!lib$es6$promise$utils$$isArray(entries)) {\n      lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n      return promise;\n    }\n\n    var length = entries.length;\n\n    function onFulfillment(value) {\n      lib$es6$promise$$internal$$resolve(promise, value);\n    }\n\n    function onRejection(reason) {\n      lib$es6$promise$$internal$$reject(promise, reason);\n    }\n\n    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n      lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n    }\n\n    return promise;\n  }\n  var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n  function lib$es6$promise$promise$resolve$$resolve(object) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && typeof object === 'object' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$resolve(promise, object);\n    return promise;\n  }\n  var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n  function lib$es6$promise$promise$reject$$reject(reason) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$es6$promise$$internal$$noop);\n    lib$es6$promise$$internal$$reject(promise, reason);\n    return promise;\n  }\n  var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n  var lib$es6$promise$promise$$counter = 0;\n\n  function lib$es6$promise$promise$$needsResolver() {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  function lib$es6$promise$promise$$needsNew() {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n  /**\n    Promise objects represent the eventual result of an asynchronous operation. The\n    primary way of interacting with a promise is through its `then` method, which\n    registers callbacks to receive either a promise's eventual value or the reason\n    why the promise cannot be fulfilled.\n     Terminology\n    -----------\n     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n    - `thenable` is an object or function that defines a `then` method.\n    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n    - `exception` is a value that is thrown using the throw statement.\n    - `reason` is a value that indicates why a promise was rejected.\n    - `settled` the final resting state of a promise, fulfilled or rejected.\n     A promise can be in one of three states: pending, fulfilled, or rejected.\n     Promises that are fulfilled have a fulfillment value and are in the fulfilled\n    state.  Promises that are rejected have a rejection reason and are in the\n    rejected state.  A fulfillment value is never a thenable.\n     Promises can also be said to *resolve* a value.  If this value is also a\n    promise, then the original promise's settled state will match the value's\n    settled state.  So a promise that *resolves* a promise that rejects will\n    itself reject, and a promise that *resolves* a promise that fulfills will\n    itself fulfill.\n      Basic Usage:\n    ------------\n     ```js\n    var promise = new Promise(function(resolve, reject) {\n      // on success\n      resolve(value);\n       // on failure\n      reject(reason);\n    });\n     promise.then(function(value) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Advanced Usage:\n    ---------------\n     Promises shine when abstracting away asynchronous interactions such as\n    `XMLHttpRequest`s.\n     ```js\n    function getJSON(url) {\n      return new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n         xhr.open('GET', url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = 'json';\n        xhr.setRequestHeader('Accept', 'application/json');\n        xhr.send();\n         function handler() {\n          if (this.readyState === this.DONE) {\n            if (this.status === 200) {\n              resolve(this.response);\n            } else {\n              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n            }\n          }\n        };\n      });\n    }\n     getJSON('/posts.json').then(function(json) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n     Unlike callbacks, promises are great composable primitives.\n     ```js\n    Promise.all([\n      getJSON('/posts'),\n      getJSON('/comments')\n    ]).then(function(values){\n      values[0] // => postsJSON\n      values[1] // => commentsJSON\n       return values;\n    });\n    ```\n     @class Promise\n    @param {function} resolver\n    Useful for tooling.\n    @constructor\n  */\n  function lib$es6$promise$promise$$Promise(resolver) {\n    this._id = lib$es6$promise$promise$$counter++;\n    this._state = undefined;\n    this._result = undefined;\n    this._subscribers = [];\n\n    if (lib$es6$promise$$internal$$noop !== resolver) {\n      if (!lib$es6$promise$utils$$isFunction(resolver)) {\n        lib$es6$promise$promise$$needsResolver();\n      }\n\n      if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n        lib$es6$promise$promise$$needsNew();\n      }\n\n      lib$es6$promise$$internal$$initializePromise(this, resolver);\n    }\n  }\n\n  lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n  lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n  lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n  lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n  lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n  lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n  lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n  lib$es6$promise$promise$$Promise.prototype = {\n    constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n       ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n       Chaining\n      --------\n       The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n       ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n       findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n       ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n       Assimilation\n      ------------\n       Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n       If the assimliated promise rejects, then the downstream promise will also reject.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n       Simple Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var result;\n       try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n       Advanced Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var author, books;\n       try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n       function foundBooks(books) {\n       }\n       function failure(reason) {\n       }\n       findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n    then: function then(onFulfillment, onRejection) {\n      var parent = this;\n      var state = parent._state;\n\n      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n        return this;\n      }\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n      var result = parent._result;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function () {\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n       ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n       // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n       // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n    'catch': function _catch(onRejection) {\n      return this.then(null, onRejection);\n    }\n  };\n  function lib$es6$promise$polyfill$$polyfill() {\n    var local;\n\n    if (typeof global !== 'undefined') {\n      local = global;\n    } else if (typeof self !== 'undefined') {\n      local = self;\n    } else {\n      try {\n        local = Function('return this')();\n      } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n      }\n    }\n\n    var P = local.Promise;\n\n    if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n      return;\n    }\n\n    local.Promise = lib$es6$promise$promise$$default;\n  }\n  var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n  var lib$es6$promise$umd$$ES6Promise = {\n    'Promise': lib$es6$promise$promise$$default,\n    'polyfill': lib$es6$promise$polyfill$$default\n  };\n\n  /* global define:true module:true window: true */\n  if (\"function\" === 'function' && __webpack_require__(5)['amd']) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return lib$es6$promise$umd$$ES6Promise;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== 'undefined' && module['exports']) {\n    module['exports'] = lib$es6$promise$umd$$ES6Promise;\n  } else if (typeof this !== 'undefined') {\n    this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n  }\n\n  lib$es6$promise$polyfill$$default();\n}).call(undefined);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), (function() { return this; }()), __webpack_require__(4)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/es6-promise/promise.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/es6-promise/promise.js?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("'use strict';\n\n(function () {\n  'use strict';\n\n  if (self.fetch) {\n    return;\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name');\n    }\n    return name.toLowerCase();\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value;\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function (value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function (name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function (name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var list = this.map[name];\n    if (!list) {\n      list = [];\n      this.map[name] = list;\n    }\n    list.push(value);\n  };\n\n  Headers.prototype['delete'] = function (name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function (name) {\n    var values = this.map[normalizeName(name)];\n    return values ? values[0] : null;\n  };\n\n  Headers.prototype.getAll = function (name) {\n    return this.map[normalizeName(name)] || [];\n  };\n\n  Headers.prototype.has = function (name) {\n    return this.map.hasOwnProperty(normalizeName(name));\n  };\n\n  Headers.prototype.set = function (name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)];\n  };\n\n  Headers.prototype.forEach = function (callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function (name) {\n      this.map[name].forEach(function (value) {\n        callback.call(thisArg, value, name, this);\n      }, this);\n    }, this);\n  };\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'));\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function (resolve, reject) {\n      reader.onload = function () {\n        resolve(reader.result);\n      };\n      reader.onerror = function () {\n        reject(reader.error);\n      };\n    });\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    reader.readAsArrayBuffer(blob);\n    return fileReaderReady(reader);\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    reader.readAsText(blob);\n    return fileReaderReady(reader);\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function () {\n      try {\n        new Blob();\n        return true;\n      } catch (e) {\n        return false;\n      }\n    })(),\n    formData: 'FormData' in self\n  };\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function (body) {\n      this._bodyInit = body;\n      if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (!body) {\n        this._bodyText = '';\n      } else {\n        throw new Error('unsupported BodyInit type');\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function () {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob);\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob');\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]));\n        }\n      };\n\n      this.arrayBuffer = function () {\n        return this.blob().then(readBlobAsArrayBuffer);\n      };\n\n      this.text = function () {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text');\n        } else {\n          return Promise.resolve(this._bodyText);\n        }\n      };\n    } else {\n      this.text = function () {\n        var rejected = consumed(this);\n        return rejected ? rejected : Promise.resolve(this._bodyText);\n      };\n    }\n\n    if (support.formData) {\n      this.formData = function () {\n        return this.text().then(decode);\n      };\n    }\n\n    this.json = function () {\n      return this.text().then(JSON.parse);\n    };\n\n    return this;\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method;\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read');\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = input;\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests');\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function () {\n    return new Request(this);\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function (bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form;\n  }\n\n  function headers(xhr) {\n    var head = new Headers();\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n');\n    pairs.forEach(function (header) {\n      var split = header.trim().split(':');\n      var key = split.shift().trim();\n      var value = split.join(':').trim();\n      head.append(key, value);\n    });\n    return head;\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this._initBody(bodyInit);\n    this.type = 'default';\n    this.status = options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText;\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);\n    this.url = options.url || '';\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function () {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    });\n  };\n\n  Response.error = function () {\n    var response = new Response(null, { status: 0, statusText: '' });\n    response.type = 'error';\n    return response;\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function (url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code');\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function (input, init) {\n    return new Promise(function (resolve, reject) {\n      var request;\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input;\n      } else {\n        request = new Request(input, init);\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL;\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL');\n        }\n\n        return;\n      }\n\n      xhr.onload = function () {\n        var status = xhr.status === 1223 ? 204 : xhr.status;\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'));\n          return;\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        };\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function () {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function (value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    });\n  };\n  self.fetch.polyfill = true;\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/fetch/fetch.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./bower_components/fetch/fetch.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Module dependencies.\n */\n\nvar slice = __webpack_require__(8)\nvar flatten = __webpack_require__(10)\n\n/**\n * This function lets us create virtual nodes using a simple\n * syntax. It is compatible with JSX transforms so you can use\n * JSX to write nodes that will compile to this function.\n *\n * let node = element('div', { id: 'foo' }, [\n *   element('a', { href: 'http://google.com' }, 'Google')\n * ])\n *\n * You can leave out the attributes or the children if either\n * of them aren't needed and it will figure out what you're\n * trying to do.\n */\n\nmodule.exports = element\n\n/**\n * Create virtual trees of components.\n *\n * This creates the nicer API for the user.\n * It translates that friendly API into an actual tree of nodes.\n *\n * @param {*} type\n * @param {Object} attributes\n * @param {Array} children\n * @return {Object}\n * @api public\n */\n\nfunction element (type, attributes, children) {\n  // Default to div with no args\n  if (!type) {\n    throw new TypeError('element() needs a type.')\n  }\n\n  // Skipped adding attributes and we're passing\n  // in children instead.\n  if (arguments.length === 2 && (typeof attributes === 'string' || Array.isArray(attributes))) {\n    children = [ attributes ]\n    attributes = {}\n  }\n\n  // Account for JSX putting the children as multiple arguments.\n  // This is essentially just the ES6 rest param\n  if (arguments.length > 2) {\n    children = slice(arguments, 2)\n  }\n\n  children = children || []\n  attributes = attributes || {}\n\n  // Flatten nested child arrays. This is how JSX compiles some nodes.\n  children = flatten(children, 2)\n\n  // Filter out any `undefined` elements\n  children = children.filter(function (i) { return typeof i !== 'undefined' })\n\n  // if you pass in a function, it's a `Component` constructor.\n  // otherwise it's an element.\n  return {\n    type: type,\n    children: children,\n    attributes: attributes\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-element/index.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/virtual-element/index.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = exports = __webpack_require__(9);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-element/~/sliced/index.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/virtual-element/~/sliced/index.js?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-element/~/sliced/lib/sliced.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/virtual-element/~/sliced/lib/sliced.js?");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("'use strict'\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = arrayFlatten\n\n/**\n * Recursive flatten function with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {Number} depth\n * @return {Array}\n */\nfunction flattenWithDepth (array, result, depth) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > 0 && Array.isArray(value)) {\n      flattenWithDepth(value, result, depth - 1)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Recursive flatten function. Omitting depth is slightly faster.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenForever (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenForever(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array, with the ability to define a depth.\n *\n * @param  {Array}  array\n * @param  {Number} depth\n * @return {Array}\n */\nfunction arrayFlatten (array, depth) {\n  if (depth == null) {\n    return flattenForever(array, [])\n  }\n\n  return flattenWithDepth(array, [], depth)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-element/~/array-flatten/array-flatten.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/virtual-element/~/array-flatten/array-flatten.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Create the application.\n */\n\nexports.tree =\nexports.scene =\nexports.deku = __webpack_require__(12)\n\n/**\n * Render scenes to the DOM.\n */\n\nif (typeof document !== 'undefined') {\n  exports.render = __webpack_require__(14)\n}\n\n/**\n * Render scenes to a string\n */\n\nexports.renderString = __webpack_require__(39)\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/index.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/index.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Module dependencies.\n */\n\nvar Emitter = __webpack_require__(13)\n\n/**\n * Expose `scene`.\n */\n\nmodule.exports = Application\n\n/**\n * Create a new `Application`.\n *\n * @param {Object} element Optional initial element\n */\n\nfunction Application (element) {\n  if (!(this instanceof Application)) return new Application(element)\n  this.options = {}\n  this.sources = {}\n  this.element = element\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Application.prototype)\n\n/**\n * Add a plugin\n *\n * @param {Function} plugin\n */\n\nApplication.prototype.use = function (plugin) {\n  plugin(this)\n  return this\n}\n\n/**\n * Set an option\n *\n * @param {String} name\n */\n\nApplication.prototype.option = function (name, val) {\n  this.options[name] = val\n  return this\n}\n\n/**\n * Set value used somewhere in the IO network.\n */\n\nApplication.prototype.set = function (name, data) {\n  this.sources[name] = data\n  this.emit('source', name, data)\n  return this\n}\n\n/**\n * Mount a virtual element.\n *\n * @param {VirtualElement} element\n */\n\nApplication.prototype.mount = function (element) {\n  this.element = element\n  this.emit('mount', element)\n  return this\n}\n\n/**\n * Remove the world. Unmount everything.\n */\n\nApplication.prototype.unmount = function () {\n  if (!this.element) return\n  this.element = null\n  this.emit('unmount')\n  return this\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/application.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/application.js?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks['$' + event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/component-emitter/index.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/component-emitter/index.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Dependencies.\n */\n\nvar raf = __webpack_require__(15)\nvar isDom = __webpack_require__(16)\nvar uid = __webpack_require__(17)\nvar keypath = __webpack_require__(18)\nvar events = __webpack_require__(19)\nvar svg = __webpack_require__(20)\nvar defaults = __webpack_require__(23)\nvar forEach = __webpack_require__(24)\nvar assign = __webpack_require__(28)\nvar reduce = __webpack_require__(29)\nvar nodeType = __webpack_require__(33)\n\n/**\n * Expose `dom`.\n */\n\nmodule.exports = render\n\n/**\n * Render an app to the DOM\n *\n * @param {Application} app\n * @param {HTMLElement} container\n * @param {Object} opts\n *\n * @return {Object}\n */\n\nfunction render (app, container, opts) {\n  var frameId\n  var isRendering\n  var rootId = 'root'\n  var currentElement\n  var currentNativeElement\n  var connections = {}\n  var components = {}\n  var entities = {}\n  var handlers = {}\n  var mountQueue = []\n  var children = {}\n  children[rootId] = {}\n\n  if (!isDom(container)) {\n    throw new Error('Container element must be a DOM element')\n  }\n\n  /**\n   * Rendering options. Batching is only ever really disabled\n   * when running tests, and pooling can be disabled if the user\n   * is doing something stupid with the DOM in their components.\n   */\n\n  var options = defaults(assign({}, app.options || {}, opts || {}), {\n    batching: true\n  })\n\n  /**\n   * Listen to DOM events\n   */\n  var rootElement = getRootElement(container)\n  addNativeEventListeners()\n\n  /**\n   * Watch for changes to the app so that we can update\n   * the DOM as needed.\n   */\n\n  app.on('unmount', onunmount)\n  app.on('mount', onmount)\n  app.on('source', onupdate)\n\n  /**\n   * If the app has already mounted an element, we can just\n   * render that straight away.\n   */\n\n  if (app.element) render()\n\n  /**\n   * Teardown the DOM rendering so that it stops\n   * rendering and everything can be garbage collected.\n   */\n\n  function teardown () {\n    removeNativeEventListeners()\n    removeNativeElement()\n    app.off('unmount', onunmount)\n    app.off('mount', onmount)\n    app.off('source', onupdate)\n  }\n\n  /**\n   * Swap the current rendered node with a new one that is rendered\n   * from the new virtual element mounted on the app.\n   *\n   * @param {VirtualElement} element\n   */\n\n  function onmount () {\n    invalidate()\n  }\n\n  /**\n   * If the app unmounts an element, we should clear out the current\n   * rendered element. This will remove all the entities.\n   */\n\n  function onunmount () {\n    removeNativeElement()\n    currentElement = null\n  }\n\n  /**\n   * Update all components that are bound to the source\n   *\n   * @param {String} name\n   * @param {*} data\n   */\n\n  function onupdate (name, data) {\n    if (!connections[name]) return;\n    connections[name].forEach(function(update) {\n      update(data)\n    })\n  }\n\n  /**\n   * Render and mount a component to the native dom.\n   *\n   * @param {Entity} entity\n   * @return {HTMLElement}\n   */\n\n  function mountEntity (entity) {\n    register(entity)\n    setSources(entity)\n    children[entity.id] = {}\n    entities[entity.id] = entity\n\n    // commit initial state and props.\n    commit(entity)\n\n    // callback before mounting.\n    trigger('beforeMount', entity, [entity.context])\n    trigger('beforeRender', entity, [entity.context])\n\n    // render virtual element.\n    var virtualElement = renderEntity(entity)\n    // create native element.\n    var nativeElement = toNative(entity.id, '0', virtualElement)\n\n    entity.virtualElement = virtualElement\n    entity.nativeElement = nativeElement\n\n    // Fire afterRender and afterMount hooks at the end\n    // of the render cycle\n    mountQueue.push(entity.id)\n\n    return nativeElement\n  }\n\n  /**\n   * Remove a component from the native dom.\n   *\n   * @param {Entity} entity\n   */\n\n  function unmountEntity (entityId) {\n    var entity = entities[entityId]\n    if (!entity) return\n    trigger('beforeUnmount', entity, [entity.context, entity.nativeElement])\n    unmountChildren(entityId)\n    removeAllEvents(entityId)\n    var componentEntities = components[entityId].entities;\n    delete componentEntities[entityId]\n    delete components[entityId]\n    delete entities[entityId]\n    delete children[entityId]\n  }\n\n  /**\n   * Render the entity and make sure it returns a node\n   *\n   * @param {Entity} entity\n   *\n   * @return {VirtualTree}\n   */\n\n  function renderEntity (entity) {\n    var component = entity.component\n    var fn = typeof component === 'function' ? component : component.render\n    if (!fn) throw new Error('Component needs a render function')\n    var result = fn(entity.context, setState(entity))\n    if (!result) throw new Error('Render function must return an element.')\n    return result\n  }\n\n  /**\n   * Whenever setState or setProps is called, we mark the entity\n   * as dirty in the renderer. This lets us optimize the re-rendering\n   * and skip components that definitely haven't changed.\n   *\n   * @param {Entity} entity\n   *\n   * @return {Function} A curried function for updating the state of an entity\n   */\n\n  function setState (entity) {\n    return function (nextState) {\n      updateEntityState(entity, nextState)\n    }\n  }\n\n  /**\n   * Tell the app it's dirty and needs to re-render. If batching is disabled\n   * we can just trigger a render immediately, otherwise we'll wait until\n   * the next available frame.\n   */\n\n  function invalidate () {\n    if (!options.batching) {\n      if (!isRendering) render()\n    } else {\n      if (!frameId) frameId = raf(render)\n    }\n  }\n\n  /**\n   * Update the DOM. If the update fails we stop the loop\n   * so we don't get errors on every frame.\n   *\n   * @api public\n   */\n\n  function render () {\n    // If this is called synchronously we need to\n    // cancel any pending future updates\n    clearFrame()\n\n    // If the rendering from the previous frame is still going,\n    // we'll just wait until the next frame. Ideally renders should\n    // not take over 16ms to stay within a single frame, but this should\n    // catch it if it does.\n    if (isRendering) {\n      frameId = raf(render)\n      return\n    } else {\n      isRendering = true\n    }\n\n    // 1. If there isn't a native element rendered for the current mounted element\n    // then we need to create it from scratch.\n    // 2. If a new element has been mounted, we should diff them.\n    // 3. We should update check all child components for changes.\n    if (!currentNativeElement) {\n      currentElement = app.element\n      currentNativeElement = toNative(rootId, '0', currentElement)\n      if (container.children.length > 0) {\n        console.info('deku: The container element is not empty. These elements will be removed. Read more: http://cl.ly/b0Sr')\n      }\n      if (container === document.body) {\n        console.warn('deku: Using document.body is allowed but it can cause some issues. Read more: http://cl.ly/b0SC')\n      }\n      removeAllChildren(container)\n      container.appendChild(currentNativeElement)\n    } else if (currentElement !== app.element) {\n      currentNativeElement = patch(rootId, currentElement, app.element, currentNativeElement)\n      currentElement = app.element\n      updateChildren(rootId)\n    } else {\n      updateChildren(rootId)\n    }\n\n    // Call mount events on all new entities\n    flushMountQueue()\n\n    // Allow rendering again.\n    isRendering = false\n\n  }\n\n  /**\n   * Call hooks for all new entities that have been created in\n   * the last render from the bottom up.\n   */\n\n  function flushMountQueue () {\n    while (mountQueue.length > 0) {\n      var entityId = mountQueue.shift()\n      var entity = entities[entityId]\n      trigger('afterRender', entity, [entity.context, entity.nativeElement])\n      trigger('afterMount', entity, [entity.context, entity.nativeElement, setState(entity)])\n    }\n  }\n\n  /**\n   * Clear the current scheduled frame\n   */\n\n  function clearFrame () {\n    if (!frameId) return\n    raf.cancel(frameId)\n    frameId = 0\n  }\n\n  /**\n   * Update a component.\n   *\n   * The entity is just the data object for a component instance.\n   *\n   * @param {String} id Component instance id.\n   */\n\n  function updateEntity (entityId) {\n    var entity = entities[entityId]\n    setSources(entity)\n\n    if (!shouldUpdate(entity)) {\n      commit(entity)\n      return updateChildren(entityId)\n    }\n\n    var currentTree = entity.virtualElement\n    var nextProps = entity.pendingProps\n    var nextState = entity.pendingState\n    var previousState = entity.context.state\n    var previousProps = entity.context.props\n\n    // hook before rendering. could modify state just before the render occurs.\n    trigger('beforeUpdate', entity, [entity.context, nextProps, nextState])\n    trigger('beforeRender', entity, [entity.context])\n\n    // commit state and props.\n    commit(entity)\n\n    // re-render.\n    var nextTree = renderEntity(entity)\n\n    // if the tree is the same we can just skip this component\n    // but we should still check the children to see if they're dirty.\n    // This allows us to memoize the render function of components.\n    if (nextTree === currentTree) return updateChildren(entityId)\n\n    // apply new virtual tree to native dom.\n    entity.nativeElement = patch(entityId, currentTree, nextTree, entity.nativeElement)\n    entity.virtualElement = nextTree\n    updateChildren(entityId)\n\n    // trigger render hook\n    trigger('afterRender', entity, [entity.context, entity.nativeElement])\n\n    // trigger afterUpdate after all children have updated.\n    trigger('afterUpdate', entity, [entity.context, previousProps, previousState, setState(entity)])\n  }\n\n  /**\n   * Update all the children of an entity.\n   *\n   * @param {String} id Component instance id.\n   */\n\n  function updateChildren (entityId) {\n    forEach(children[entityId], function (childId) {\n      updateEntity(childId)\n    })\n  }\n\n  /**\n   * Remove all of the child entities of an entity\n   *\n   * @param {Entity} entity\n   */\n\n  function unmountChildren (entityId) {\n    forEach(children[entityId], function (childId) {\n      unmountEntity(childId)\n    })\n  }\n\n  /**\n   * Remove the root element. If this is called synchronously we need to\n   * cancel any pending future updates.\n   */\n\n  function removeNativeElement () {\n    clearFrame()\n    removeElement(rootId, '0', currentNativeElement)\n    currentNativeElement = null\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   *\n   * @param {String} entityId\n   * @param {String} path\n   * @param {Object} vnode\n   *\n   * @return {HTMLDocumentFragment}\n   */\n\n  function toNative (entityId, path, vnode) {\n    switch (nodeType(vnode)) {\n      case 'text': return toNativeText(vnode)\n      case 'empty': return toNativeEmptyElement(entityId, path)\n      case 'element': return toNativeElement(entityId, path, vnode)\n      case 'component': return toNativeComponent(entityId, path, vnode)\n    }\n  }\n\n  /**\n   * Create a native text element from a virtual element.\n   *\n   * @param {Object} vnode\n   */\n\n  function toNativeText (text) {\n    return document.createTextNode(text)\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   */\n\n  function toNativeElement (entityId, path, vnode) {\n    var el\n    var attributes = vnode.attributes\n    var tagName = vnode.type\n    var childNodes = vnode.children\n\n    // create element either from pool or fresh.\n    if (svg.isElement(tagName)) {\n      el = document.createElementNS(svg.namespace, tagName)\n    } else {\n      el = document.createElement(tagName)\n    }\n\n    // set attributes.\n    forEach(attributes, function (value, name) {\n      setAttribute(entityId, path, el, name, value)\n    })\n\n    // add children.\n    forEach(childNodes, function (child, i) {\n      var childEl = toNative(entityId, path + '.' + i, child)\n      if (!childEl.parentNode) el.appendChild(childEl)\n    })\n\n    // store keys on the native element for fast event handling.\n    el.__entity__ = entityId\n    el.__path__ = path\n\n    return el\n  }\n\n  /**\n   * Create a native element from a virtual element.\n   */\n\n  function toNativeEmptyElement (entityId, path) {\n    var el = document.createElement('noscript')\n    el.__entity__ = entityId\n    el.__path__ = path\n    return el\n  }\n\n  /**\n   * Create a native element from a component.\n   */\n\n  function toNativeComponent (entityId, path, vnode) {\n    var child = new Entity(vnode.type, assign({ children: vnode.children }, vnode.attributes), entityId)\n    children[entityId][path] = child.id\n    return mountEntity(child)\n  }\n\n  /**\n   * Patch an element with the diff from two trees.\n   */\n\n  function patch (entityId, prev, next, el) {\n    return diffNode('0', entityId, prev, next, el)\n  }\n\n  /**\n   * Create a diff between two trees of nodes.\n   */\n\n  function diffNode (path, entityId, prev, next, el) {\n    var leftType = nodeType(prev)\n    var rightType = nodeType(next)\n\n    // Type changed. This could be from element->text, text->ComponentA,\n    // ComponentA->ComponentB etc. But NOT div->span. These are the same type\n    // (ElementNode) but different tag name.\n    if (leftType !== rightType) return replaceElement(entityId, path, el, next)\n\n    switch (rightType) {\n      case 'text': return diffText(prev, next, el)\n      case 'empty': return el\n      case 'element': return diffElement(path, entityId, prev, next, el)\n      case 'component': return diffComponent(path, entityId, prev, next, el)\n    }\n  }\n\n  /**\n   * Diff two text nodes and update the element.\n   */\n\n  function diffText (previous, current, el) {\n    if (current !== previous) el.data = current\n    return el\n  }\n\n  /**\n   * Diff the children of an ElementNode.\n   */\n\n  function diffChildren (path, entityId, prev, next, el) {\n    var positions = []\n    var hasKeys = false\n    var childNodes = Array.prototype.slice.apply(el.childNodes)\n    var leftKeys = reduce(prev.children, keyMapReducer, {})\n    var rightKeys = reduce(next.children, keyMapReducer, {})\n    var currentChildren = assign({}, children[entityId])\n\n    function keyMapReducer (acc, child, i) {\n      if (child && child.attributes && child.attributes.key != null) {\n        acc[child.attributes.key] = {\n          element: child,\n          index: i\n        }\n        hasKeys = true\n      }\n      return acc\n    }\n\n    // Diff all of the nodes that have keys. This lets us re-used elements\n    // instead of overriding them and lets us move them around.\n    if (hasKeys) {\n\n      // Removals\n      forEach(leftKeys, function (leftNode, key) {\n        if (rightKeys[key] == null) {\n          var leftPath = path + '.' + leftNode.index\n          removeElement(\n            entityId,\n            leftPath,\n            childNodes[leftNode.index]\n          )\n        }\n      })\n\n      // Update nodes\n      forEach(rightKeys, function (rightNode, key) {\n        var leftNode = leftKeys[key]\n\n        // We only want updates for now\n        if (leftNode == null) return\n\n        var leftPath = path + '.' + leftNode.index\n\n        // Updated\n        positions[rightNode.index] = diffNode(\n          leftPath,\n          entityId,\n          leftNode.element,\n          rightNode.element,\n          childNodes[leftNode.index]\n        )\n      })\n\n      // Update the positions of all child components and event handlers\n      forEach(rightKeys, function (rightNode, key) {\n        var leftNode = leftKeys[key]\n\n        // We just want elements that have moved around\n        if (leftNode == null || leftNode.index === rightNode.index) return\n\n        var rightPath = path + '.' + rightNode.index\n        var leftPath = path + '.' + leftNode.index\n\n        // Update all the child component path positions to match\n        // the latest positions if they've changed. This is a bit hacky.\n        forEach(currentChildren, function (childId, childPath) {\n          if (leftPath === childPath) {\n            delete children[entityId][childPath]\n            children[entityId][rightPath] = childId\n          }\n        })\n      })\n\n      // Now add all of the new nodes last in case their path\n      // would have conflicted with one of the previous paths.\n      forEach(rightKeys, function (rightNode, key) {\n        var rightPath = path + '.' + rightNode.index\n        if (leftKeys[key] == null) {\n          positions[rightNode.index] = toNative(\n            entityId,\n            rightPath,\n            rightNode.element\n          )\n        }\n      })\n\n    } else {\n      var maxLength = Math.max(prev.children.length, next.children.length)\n\n      // Now diff all of the nodes that don't have keys\n      for (var i = 0; i < maxLength; i++) {\n        var leftNode = prev.children[i]\n        var rightNode = next.children[i]\n\n        // Removals\n        if (rightNode === undefined) {\n          removeElement(\n            entityId,\n            path + '.' + i,\n            childNodes[i]\n          )\n          continue\n        }\n\n        // New Node\n        if (leftNode === undefined) {\n          positions[i] = toNative(\n            entityId,\n            path + '.' + i,\n            rightNode\n          )\n          continue\n        }\n\n        // Updated\n        positions[i] = diffNode(\n          path + '.' + i,\n          entityId,\n          leftNode,\n          rightNode,\n          childNodes[i]\n        )\n      }\n    }\n\n    // Reposition all the elements\n    forEach(positions, function (childEl, newPosition) {\n      var target = el.childNodes[newPosition]\n      if (childEl && childEl !== target) {\n        if (target) {\n          el.insertBefore(childEl, target)\n        } else {\n          el.appendChild(childEl)\n        }\n      }\n    })\n  }\n\n  /**\n   * Diff the attributes and add/remove them.\n   */\n\n  function diffAttributes (prev, next, el, entityId, path) {\n    var nextAttrs = next.attributes\n    var prevAttrs = prev.attributes\n\n    // add new attrs\n    forEach(nextAttrs, function (value, name) {\n      if (events[name] || !(name in prevAttrs) || prevAttrs[name] !== value) {\n        setAttribute(entityId, path, el, name, value)\n      }\n    })\n\n    // remove old attrs\n    forEach(prevAttrs, function (value, name) {\n      if (!(name in nextAttrs)) {\n        removeAttribute(entityId, path, el, name)\n      }\n    })\n  }\n\n  /**\n   * Update a component with the props from the next node. If\n   * the component type has changed, we'll just remove the old one\n   * and replace it with the new component.\n   */\n\n  function diffComponent (path, entityId, prev, next, el) {\n    if (next.type !== prev.type) {\n      return replaceElement(entityId, path, el, next)\n    } else {\n      var targetId = children[entityId][path]\n\n      // This is a hack for now\n      if (targetId) {\n        updateEntityProps(targetId, assign({ children: next.children }, next.attributes))\n      }\n\n      return el\n    }\n  }\n\n  /**\n   * Diff two element nodes.\n   */\n\n  function diffElement (path, entityId, prev, next, el) {\n    if (next.type !== prev.type) return replaceElement(entityId, path, el, next)\n    diffAttributes(prev, next, el, entityId, path)\n    diffChildren(path, entityId, prev, next, el)\n    return el\n  }\n\n  /**\n   * Removes an element from the DOM and unmounts and components\n   * that are within that branch\n   *\n   * side effects:\n   *   - removes element from the DOM\n   *   - removes internal references\n   *\n   * @param {String} entityId\n   * @param {String} path\n   * @param {HTMLElement} el\n   */\n\n  function removeElement (entityId, path, el) {\n    var childrenByPath = children[entityId]\n    var childId = childrenByPath[path]\n    var entityHandlers = handlers[entityId] || {}\n    var removals = []\n\n    // If the path points to a component we should use that\n    // components element instead, because it might have moved it.\n    if (childId) {\n      var child = entities[childId]\n      el = child.nativeElement\n      unmountEntity(childId)\n      removals.push(path)\n    } else {\n\n      // Just remove the text node\n      if (!isElement(el)) return el && el.parentNode.removeChild(el)\n\n      // Then we need to find any components within this\n      // branch and unmount them.\n      forEach(childrenByPath, function (childId, childPath) {\n        if (childPath === path || isWithinPath(path, childPath)) {\n          unmountEntity(childId)\n          removals.push(childPath)\n        }\n      })\n\n      // Remove all events at this path or below it\n      forEach(entityHandlers, function (fn, handlerPath) {\n        if (handlerPath === path || isWithinPath(path, handlerPath)) {\n          removeEvent(entityId, handlerPath)\n        }\n      })\n    }\n\n    // Remove the paths from the object without touching the\n    // old object. This keeps the object using fast properties.\n    forEach(removals, function (path) {\n      delete children[entityId][path]\n    })\n\n    // Remove it from the DOM\n    el.parentNode.removeChild(el)\n  }\n\n  /**\n   * Replace an element in the DOM. Removing all components\n   * within that element and re-rendering the new virtual node.\n   *\n   * @param {Entity} entity\n   * @param {String} path\n   * @param {HTMLElement} el\n   * @param {Object} vnode\n   *\n   * @return {void}\n   */\n\n  function replaceElement (entityId, path, el, vnode) {\n    var parent = el.parentNode\n    var index = Array.prototype.indexOf.call(parent.childNodes, el)\n\n    // remove the previous element and all nested components. This\n    // needs to happen before we create the new element so we don't\n    // get clashes on the component paths.\n    removeElement(entityId, path, el)\n\n    // then add the new element in there\n    var newEl = toNative(entityId, path, vnode)\n    var target = parent.childNodes[index]\n\n    if (target) {\n      parent.insertBefore(newEl, target)\n    } else {\n      parent.appendChild(newEl)\n    }\n\n    // walk up the tree and update all `entity.nativeElement` references.\n    if (entityId !== 'root' && path === '0') {\n      updateNativeElement(entityId, newEl)\n    }\n\n    return newEl\n  }\n\n  /**\n   * Update all entities in a branch that have the same nativeElement. This\n   * happens when a component has another component as it's root node.\n   *\n   * @param {String} entityId\n   * @param {HTMLElement} newEl\n   *\n   * @return {void}\n   */\n\n  function updateNativeElement (entityId, newEl) {\n    var target = entities[entityId]\n    if (target.ownerId === 'root') return\n    if (children[target.ownerId]['0'] === entityId) {\n      entities[target.ownerId].nativeElement = newEl\n      updateNativeElement(target.ownerId, newEl)\n    }\n  }\n\n  /**\n   * Set the attribute of an element, performing additional transformations\n   * dependning on the attribute name\n   *\n   * @param {HTMLElement} el\n   * @param {String} name\n   * @param {String} value\n   */\n\n  function setAttribute (entityId, path, el, name, value) {\n    if (!value) {\n      removeAttribute(entityId, path, el, name)\n      return\n    }\n    if (events[name]) {\n      addEvent(entityId, path, events[name], value)\n      return\n    }\n    switch (name) {\n      case 'checked':\n      case 'disabled':\n      case 'selected':\n        el[name] = true\n        break\n      case 'innerHTML':\n        el.innerHTML = value\n        break\n      case 'value':\n        setElementValue(el, value)\n        break\n      case svg.isAttribute(name):\n        el.setAttributeNS(svg.namespace, name, value)\n        break\n      default:\n        el.setAttribute(name, value)\n        break\n    }\n  }\n\n  /**\n   * Remove an attribute, performing additional transformations\n   * dependning on the attribute name\n   *\n   * @param {HTMLElement} el\n   * @param {String} name\n   */\n\n  function removeAttribute (entityId, path, el, name) {\n    if (events[name]) {\n      removeEvent(entityId, path, events[name])\n      return\n    }\n    switch (name) {\n      case 'checked':\n      case 'disabled':\n      case 'selected':\n        el[name] = false\n        break\n      case 'innerHTML':\n        el.innerHTML = ''\n      case 'value':\n        setElementValue(el, null)\n        break\n      default:\n        el.removeAttribute(name)\n        break\n    }\n  }\n\n  /**\n   * Checks to see if one tree path is within\n   * another tree path. Example:\n   *\n   * 0.1 vs 0.1.1 = true\n   * 0.2 vs 0.3.5 = false\n   *\n   * @param {String} target\n   * @param {String} path\n   *\n   * @return {Boolean}\n   */\n\n  function isWithinPath (target, path) {\n    return path.indexOf(target + '.') === 0\n  }\n\n  /**\n   * Is the DOM node an element node\n   *\n   * @param {HTMLElement} el\n   *\n   * @return {Boolean}\n   */\n\n  function isElement (el) {\n    return !!(el && el.tagName)\n  }\n\n  /**\n   * Remove all the child nodes from an element\n   *\n   * @param {HTMLElement} el\n   */\n\n  function removeAllChildren (el) {\n    while (el.firstChild) el.removeChild(el.firstChild)\n  }\n\n  /**\n   * Trigger a hook on a component.\n   *\n   * @param {String} name Name of hook.\n   * @param {Entity} entity The component instance.\n   * @param {Array} args To pass along to hook.\n   */\n\n  function trigger (name, entity, args) {\n    if (typeof entity.component[name] !== 'function') return\n    return entity.component[name].apply(null, args)\n  }\n\n  /**\n   * Update an entity to match the latest rendered vode. We always\n   * replace the props on the component when composing them. This\n   * will trigger a re-render on all children below this point.\n   *\n   * @param {Entity} entity\n   * @param {String} path\n   * @param {Object} vnode\n   *\n   * @return {void}\n   */\n\n  function updateEntityProps (entityId, nextProps) {\n    var entity = entities[entityId]\n    entity.pendingProps = defaults({}, nextProps, entity.component.defaultProps || {})\n    entity.dirty = true\n    invalidate()\n  }\n\n  /**\n   * Update component instance state.\n   */\n\n  function updateEntityState (entity, nextState) {\n    entity.pendingState = assign(entity.pendingState, nextState)\n    entity.dirty = true\n    invalidate()\n  }\n\n  /**\n   * Commit props and state changes to an entity.\n   */\n\n  function commit (entity) {\n    entity.context = {\n      state: entity.pendingState,\n      props: entity.pendingProps,\n      id: entity.id\n    }\n    entity.pendingState = assign({}, entity.context.state)\n    entity.pendingProps = assign({}, entity.context.props)\n    entity.dirty = false\n    if (typeof entity.component.validate === 'function') {\n      entity.component.validate(entity.context)\n    }\n  }\n\n  /**\n   * Try to avoid creating new virtual dom if possible.\n   *\n   * Later we may expose this so you can override, but not there yet.\n   */\n\n  function shouldUpdate (entity) {\n    if (!entity.dirty) return false\n    if (!entity.component.shouldUpdate) return true\n    var nextProps = entity.pendingProps\n    var nextState = entity.pendingState\n    var bool = entity.component.shouldUpdate(entity.context, nextProps, nextState)\n    return bool\n  }\n\n  /**\n   * Register an entity.\n   *\n   * This is mostly to pre-preprocess component properties and values chains.\n   *\n   * The end result is for every component that gets mounted,\n   * you create a set of IO nodes in the network from the `value` definitions.\n   *\n   * @param {Component} component\n   */\n\n  function register (entity) {\n    registerEntity(entity)\n    var component = entity.component\n    if (component.registered) return\n\n    // initialize sources once for a component type.\n    registerSources(entity)\n    component.registered = true\n  }\n\n  /**\n   * Add entity to data-structures related to components/entities.\n   *\n   * @param {Entity} entity\n   */\n\n  function registerEntity(entity) {\n    var component = entity.component\n    // all entities for this component type.\n    var entities = component.entities = component.entities || {}\n    // add entity to component list\n    entities[entity.id] = entity\n    // map to component so you can remove later.\n    components[entity.id] = component\n  }\n\n  /**\n   * Initialize sources for a component by type.\n   *\n   * @param {Entity} entity\n   */\n\n  function registerSources(entity) {\n    var component = components[entity.id]\n    // get 'class-level' sources.\n    // if we've already hooked it up, then we're good.\n    var sources = component.sources\n    if (sources) return\n    var entities = component.entities\n\n    // hook up sources.\n    var map = component.sourceToPropertyName = {}\n    component.sources = sources = []\n    var propTypes = component.propTypes\n    for (var name in propTypes) {\n      var data = propTypes[name]\n      if (!data) continue\n      if (!data.source) continue\n      sources.push(data.source)\n      map[data.source] = name\n    }\n\n    // send value updates to all component instances.\n    sources.forEach(function (source) {\n      connections[source] = connections[source] || []\n      connections[source].push(update)\n\n      function update (data) {\n        var prop = map[source]\n        for (var entityId in entities) {\n          var entity = entities[entityId]\n          var changes = {}\n          changes[prop] = data\n          updateEntityProps(entityId, assign(entity.pendingProps, changes))\n        }\n      }\n    })\n  }\n\n  /**\n   * Set the initial source value on the entity\n   *\n   * @param {Entity} entity\n   */\n\n  function setSources (entity) {\n    var component = entity.component\n    var map = component.sourceToPropertyName\n    var sources = component.sources\n    sources.forEach(function (source) {\n      var name = map[source]\n      if (entity.pendingProps[name] != null) return\n      entity.pendingProps[name] = app.sources[source] // get latest value plugged into global store\n    })\n  }\n\n  /**\n   * Add all of the DOM event listeners\n   */\n\n  function addNativeEventListeners () {\n    forEach(events, function (eventType) {\n      rootElement.addEventListener(eventType, handleEvent, true)\n    })\n  }\n\n  /**\n   * Add all of the DOM event listeners\n   */\n\n  function removeNativeEventListeners () {\n    forEach(events, function (eventType) {\n      rootElement.removeEventListener(eventType, handleEvent, true)\n    })\n  }\n\n  /**\n   * Handle an event that has occured within the container\n   *\n   * @param {Event} event\n   */\n\n  function handleEvent (event) {\n    var target = event.target\n    var eventType = event.type\n\n    // Walk up the DOM tree and see if there is a handler\n    // for this event type higher up.\n    while (target) {\n      var fn = keypath.get(handlers, [target.__entity__, target.__path__, eventType])\n      if (fn) {\n        event.delegateTarget = target\n        if (fn(event) === false) break\n      }\n      target = target.parentNode\n    }\n  }\n\n  /**\n   * Bind events for an element, and all it's rendered child elements.\n   *\n   * @param {String} path\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  function addEvent (entityId, path, eventType, fn) {\n    keypath.set(handlers, [entityId, path, eventType], function (e) {\n      var entity = entities[entityId]\n      if (entity) {\n        return fn.call(null, e, entity.context, setState(entity))\n      } else {\n        return fn.call(null, e)\n      }\n    })\n  }\n\n  /**\n   * Unbind events for a entityId\n   *\n   * @param {String} entityId\n   */\n\n  function removeEvent (entityId, path, eventType) {\n    var args = [entityId]\n    if (path) args.push(path)\n    if (eventType) args.push(eventType)\n    keypath.del(handlers, args)\n  }\n\n  /**\n   * Unbind all events from an entity\n   *\n   * @param {Entity} entity\n   */\n\n  function removeAllEvents (entityId) {\n    keypath.del(handlers, [entityId])\n  }\n\n  /**\n   * Used for debugging to inspect the current state without\n   * us needing to explicitly manage storing/updating references.\n   *\n   * @return {Object}\n   */\n\n  function inspect () {\n    return {\n      entities: entities,\n      handlers: handlers,\n      connections: connections,\n      currentElement: currentElement,\n      options: options,\n      app: app,\n      container: container,\n      children: children\n    }\n  }\n\n  /**\n   * Return an object that lets us completely remove the automatic\n   * DOM rendering and export debugging tools.\n   */\n\n  return {\n    remove: teardown,\n    inspect: inspect\n  }\n}\n\n/**\n * A rendered component instance.\n *\n * This manages the lifecycle, props and state of the component.\n * It's basically just a data object for more straightfoward lookup.\n *\n * @param {Component} component\n * @param {Object} props\n */\n\nfunction Entity (component, props, ownerId) {\n  this.id = uid()\n  this.ownerId = ownerId\n  this.component = component\n  this.propTypes = component.propTypes || {}\n  this.context = {}\n  this.context.id = this.id\n  this.context.props = defaults(props || {}, component.defaultProps || {})\n  this.context.state = this.component.initialState ? this.component.initialState(this.context.props) : {}\n  this.pendingProps = assign({}, this.context.props)\n  this.pendingState = assign({}, this.context.state)\n  this.dirty = false\n  this.virtualElement = null\n  this.nativeElement = null\n  this.displayName = component.name || 'Component'\n}\n\n/**\n * Retrieve the nearest 'body' ancestor of the given element or else the root\n * element of the document in which stands the given element.\n *\n * This is necessary if you want to attach the events handler to the correct\n * element and be able to dispatch events in document fragments such as\n * Shadow DOM.\n *\n * @param  {HTMLElement} el The element on which we will render an app.\n * @return {HTMLElement}    The root element on which we will attach the events\n *                          handler.\n */\n\nfunction getRootElement (el) {\n  while (el.parentElement) {\n    if (el.tagName === 'BODY' || !el.parentElement) {\n      return el\n    }\n    el = el.parentElement\n  }\n  return el\n}\n\n/**\n * Set the value property of an element and keep the text selection\n * for input fields.\n *\n * @param {HTMLElement} el\n * @param {String} value\n */\n\nfunction setElementValue (el, value) {\n  if (el === document.activeElement && canSelectText(el)) {\n    var start = el.selectionStart\n    var end = el.selectionEnd\n    el.value = value\n    el.setSelectionRange(start, end)\n  } else {\n    el.value = value\n  }\n}\n\n/**\n * For some reason only certain types of inputs can set the selection range.\n *\n * @param {HTMLElement} el\n *\n * @return {Boolean}\n */\n\nfunction canSelectText (el) {\n  return el.tagName === 'INPUT' && ['text','search','password','tel','url'].indexOf(el.type) > -1\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/render.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/render.js?");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("/**\n * Expose `requestAnimationFrame()`.\n */\n\nexports = module.exports = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || fallback;\n\n/**\n * Fallback implementation.\n */\n\nvar prev = new Date().getTime();\nfunction fallback(fn) {\n  var curr = new Date().getTime();\n  var ms = Math.max(0, 16 - (curr - prev));\n  var req = setTimeout(fn, ms);\n  prev = curr;\n  return req;\n}\n\n/**\n * Cancel.\n */\n\nvar cancel = window.cancelAnimationFrame\n  || window.webkitCancelAnimationFrame\n  || window.mozCancelAnimationFrame\n  || window.clearTimeout;\n\nexports.cancel = function(id){\n  cancel.call(window, id);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/component-raf/index.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/component-raf/index.js?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("/*global window*/\n\n/**\n * Check if object is dom node.\n *\n * @param {Object} val\n * @return {Boolean}\n * @api public\n */\n\nmodule.exports = function isNode(val){\n  if (!val || typeof val !== 'object') return false;\n  if (window && 'object' == typeof window.Node) return val instanceof window.Node;\n  return 'number' == typeof val.nodeType && 'string' == typeof val.nodeName;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/is-dom/index.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/is-dom/index.js?");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("/** generate unique id for selector */\r\nvar counter = Date.now() % 1e9;\r\n\r\nmodule.exports = function getUid(){\r\n\treturn (Math.random() * 1e9 >>> 0) + (counter++);\r\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/get-uid/index.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/get-uid/index.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var\n    toStr = Object.prototype.toString,\n    _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (!isString(value)) {\n        for (var i in value) {\n            if (_hasOwnProperty.call(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isNumber(value){\n    return typeof value === 'number' || toString(value) === \"[object Number]\";\n  }\n\n  function isString(obj){\n    return typeof obj === 'string' || toString(obj) === \"[object String]\";\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  function isArray(obj){\n    return typeof obj === 'object' && typeof obj.length === 'number' && toString(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function set(obj, path, value, doNotReplace){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isString(path)) {\n      return set(obj, path.split('.').map(getKey), value, doNotReplace);\n    }\n    var currentPath = path[0];\n\n    if (path.length === 1) {\n      var oldVal = obj[currentPath];\n      if (oldVal === void 0 || !doNotReplace) {\n        obj[currentPath] = value;\n      }\n      return oldVal;\n    }\n\n    if (obj[currentPath] === void 0) {\n      //check if we assume an array\n      if(isNumber(path[1])) {\n        obj[currentPath] = [];\n      } else {\n        obj[currentPath] = {};\n      }\n    }\n\n    return set(obj[currentPath], path.slice(1), value, doNotReplace);\n  }\n\n  function del(obj, path) {\n    if (isNumber(path)) {\n      path = [path];\n    }\n\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if(isString(path)) {\n      return del(obj, path.split('.'));\n    }\n\n    var currentPath = getKey(path[0]);\n    var oldVal = obj[currentPath];\n\n    if(path.length === 1) {\n      if (oldVal !== void 0) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      }\n    } else {\n      if (obj[currentPath] !== void 0) {\n        return del(obj[currentPath], path.slice(1));\n      }\n    }\n\n    return obj;\n  }\n\n  var objectPath = function(obj) {\n    return Object.keys(objectPath).reduce(function(proxy, prop) {\n      if (typeof objectPath[prop] === 'function') {\n        proxy[prop] = objectPath[prop].bind(objectPath, obj);\n      }\n\n      return proxy;\n    }, {});\n  };\n\n  objectPath.has = function (obj, path) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n\n    if (isNumber(path)) {\n      path = [path];\n    } else if (isString(path)) {\n      path = path.split('.');\n    }\n\n    if (isEmpty(path) || path.length === 0) {\n      return false;\n    }\n\n    for (var i = 0; i < path.length; i++) {\n      var j = path[i];\n      if ((isObject(obj) || isArray(obj)) && _hasOwnProperty.call(obj, j)) {\n        obj = obj[j];\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  objectPath.ensureExists = function (obj, path, value){\n    return set(obj, path, value, true);\n  };\n\n  objectPath.set = function (obj, path, value, doNotReplace){\n    return set(obj, path, value, doNotReplace);\n  };\n\n  objectPath.insert = function (obj, path, value, at){\n    var arr = objectPath.get(obj, path);\n    at = ~~at;\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n    arr.splice(at, 0, value);\n  };\n\n  objectPath.empty = function(obj, path) {\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    var value, i;\n    if (!(value = objectPath.get(obj, path))) {\n      return obj;\n    }\n\n    if (isString(value)) {\n      return objectPath.set(obj, path, '');\n    } else if (isBoolean(value)) {\n      return objectPath.set(obj, path, false);\n    } else if (isNumber(value)) {\n      return objectPath.set(obj, path, 0);\n    } else if (isArray(value)) {\n      value.length = 0;\n    } else if (isObject(value)) {\n      for (i in value) {\n        if (_hasOwnProperty.call(value, i)) {\n          delete value[i];\n        }\n      }\n    } else {\n      return objectPath.set(obj, path, null);\n    }\n  };\n\n  objectPath.push = function (obj, path /*, values */){\n    var arr = objectPath.get(obj, path);\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n\n    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n  };\n\n  objectPath.coalesce = function (obj, paths, defaultValue) {\n    var value;\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n        return value;\n      }\n    }\n\n    return defaultValue;\n  };\n\n  objectPath.get = function (obj, path, defaultValue){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return defaultValue;\n    }\n    if (isString(path)) {\n      return objectPath.get(obj, path.split('.'), defaultValue);\n    }\n\n    var currentPath = getKey(path[0]);\n\n    if (path.length === 1) {\n      if (obj[currentPath] === void 0) {\n        return defaultValue;\n      }\n      return obj[currentPath];\n    }\n\n    return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n  };\n\n  objectPath.del = function(obj, path) {\n    return del(obj, path);\n  };\n\n  return objectPath;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/object-path/index.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/object-path/index.js?");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("/**\n * All of the events can bind to\n */\n\nmodule.exports = {\n  onBlur: 'blur',\n  onChange: 'change',\n  onClick: 'click',\n  onContextMenu: 'contextmenu',\n  onCopy: 'copy',\n  onCut: 'cut',\n  onDoubleClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragEnter: 'dragenter',\n  onDragExit: 'dragexit',\n  onDragLeave: 'dragleave',\n  onDragOver: 'dragover',\n  onDragStart: 'dragstart',\n  onDrop: 'drop',\n  onError: 'error',\n  onFocus: 'focus',\n  onInput: 'input',\n  onInvalid: 'invalid',\n  onKeyDown: 'keydown',\n  onKeyPress: 'keypress',\n  onKeyUp: 'keyup',\n  onMouseDown: 'mousedown',\n  onMouseEnter: 'mouseenter',\n  onMouseLeave: 'mouseleave',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onPaste: 'paste',\n  onReset: 'reset',\n  onScroll: 'scroll',\n  onSubmit: 'submit',\n  onTouchCancel: 'touchcancel',\n  onTouchEnd: 'touchend',\n  onTouchMove: 'touchmove',\n  onTouchStart: 'touchstart',\n  onWheel: 'wheel'\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/events.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/events.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = {\n  isElement: __webpack_require__(21).isElement,\n  isAttribute: __webpack_require__(22),\n  namespace: 'http://www.w3.org/2000/svg'\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/svg.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/svg.js?");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("/**\n * Supported SVG elements\n *\n * @type {Array}\n */\n\nexports.elements = {\n  'animate': true,\n  'circle': true,\n  'defs': true,\n  'ellipse': true,\n  'g': true,\n  'line': true,\n  'linearGradient': true,\n  'mask': true,\n  'path': true,\n  'pattern': true,\n  'polygon': true,\n  'polyline': true,\n  'radialGradient': true,\n  'rect': true,\n  'stop': true,\n  'svg': true,\n  'text': true,\n  'tspan': true\n}\n\n/**\n * Is element's namespace SVG?\n *\n * @param {String} name\n */\n\nexports.isElement = function (name) {\n  return name in exports.elements\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/is-svg-element/index.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/is-svg-element/index.js?");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("/**\n * Supported SVG attributes\n */\n\nexports.attributes = {\n  'cx': true,\n  'cy': true,\n  'd': true,\n  'dx': true,\n  'dy': true,\n  'fill': true,\n  'fillOpacity': true,\n  'fontFamily': true,\n  'fontSize': true,\n  'fx': true,\n  'fy': true,\n  'gradientTransform': true,\n  'gradientUnits': true,\n  'markerEnd': true,\n  'markerMid': true,\n  'markerStart': true,\n  'offset': true,\n  'opacity': true,\n  'patternContentUnits': true,\n  'patternUnits': true,\n  'points': true,\n  'preserveAspectRatio': true,\n  'r': true,\n  'rx': true,\n  'ry': true,\n  'spreadMethod': true,\n  'stopColor': true,\n  'stopOpacity': true,\n  'stroke': true,\n  'strokeDasharray': true,\n  'strokeLinecap': true,\n  'strokeOpacity': true,\n  'strokeWidth': true,\n  'textAnchor': true,\n  'transform': true,\n  'version': true,\n  'viewBox': true,\n  'x1': true,\n  'x2': true,\n  'x': true,\n  'y1': true,\n  'y2': true,\n  'y': true\n}\n\n/**\n * Are element's attributes SVG?\n *\n * @param {String} attr\n */\n\nmodule.exports = function (attr) {\n  return attr in exports.attributes\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/is-svg-attribute/index.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/is-svg-attribute/index.js?");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("'use strict'\n\nmodule.exports = function(target) {\n  target = target || {}\n\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i]\n    if (!source) continue\n\n    Object.getOwnPropertyNames(source).forEach(function(key) {\n      if (undefined === target[key])\n        target[key] = source[key]\n    })\n  }\n\n  return target\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/object-defaults/index.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/object-defaults/index.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar forEachArray = __webpack_require__(25),\n    forEachObject = __webpack_require__(27);\n\n/**\n * # ForEach\n *\n * A fast `.forEach()` implementation.\n *\n * @param  {Array|Object} subject     The array or object to iterate over.\n * @param  {Function}     fn          The visitor function.\n * @param  {Object}       thisContext The context for the visitor.\n */\nmodule.exports = function fastForEach (subject, fn, thisContext) {\n  if (subject instanceof Array) {\n    return forEachArray(subject, fn, thisContext);\n  }\n  else {\n    return forEachObject(subject, fn, thisContext);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/forEach.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/forEach.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar bindInternal3 = __webpack_require__(26);\n\n/**\n * # For Each\n *\n * A fast `.forEach()` implementation.\n *\n * @param  {Array}    subject     The array (or array-like) to iterate over.\n * @param  {Function} fn          The visitor function.\n * @param  {Object}   thisContext The context for the visitor.\n */\nmodule.exports = function fastForEach (subject, fn, thisContext) {\n  var length = subject.length,\n      iterator = thisContext !== undefined ? bindInternal3(fn, thisContext) : fn,\n      i;\n  for (i = 0; i < length; i++) {\n    iterator(subject[i], i, subject);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/array/forEach.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/array/forEach.js?");

/***/ },
/* 26 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/**\n * Internal helper to bind a function known to have 3 arguments\n * to a given context.\n */\nmodule.exports = function bindInternal3 (func, thisContext) {\n  return function (a, b, c) {\n    return func.call(thisContext, a, b, c);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/function/bindInternal3.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/function/bindInternal3.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar bindInternal3 = __webpack_require__(26);\n\n/**\n * # For Each\n *\n * A fast object `.forEach()` implementation.\n *\n * @param  {Object}   subject     The object to iterate over.\n * @param  {Function} fn          The visitor function.\n * @param  {Object}   thisContext The context for the visitor.\n */\nmodule.exports = function fastForEachObject (subject, fn, thisContext) {\n  var keys = Object.keys(subject),\n      length = keys.length,\n      iterator = thisContext !== undefined ? bindInternal3(fn, thisContext) : fn,\n      key, i;\n  for (i = 0; i < length; i++) {\n    key = keys[i];\n    iterator(subject[key], key, subject);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/object/forEach.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/object/forEach.js?");

/***/ },
/* 28 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/**\n * Analogue of Object.assign().\n * Copies properties from one or more source objects to\n * a target object. Existing keys on the target object will be overwritten.\n *\n * > Note: This differs from spec in some important ways:\n * > 1. Will throw if passed non-objects, including `undefined` or `null` values.\n * > 2. Does not support the curious Exception handling behavior, exceptions are thrown immediately.\n * > For more details, see:\n * > https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n *\n *\n *\n * @param  {Object} target      The target object to copy properties to.\n * @param  {Object} source, ... The source(s) to copy properties from.\n * @return {Object}             The updated target object.\n */\nmodule.exports = function fastAssign (target) {\n  var totalArgs = arguments.length,\n      source, i, totalKeys, keys, key, j;\n\n  for (i = 1; i < totalArgs; i++) {\n    source = arguments[i];\n    keys = Object.keys(source);\n    totalKeys = keys.length;\n    for (j = 0; j < totalKeys; j++) {\n      key = keys[j];\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/object/assign.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/object/assign.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar reduceArray = __webpack_require__(30),\n    reduceObject = __webpack_require__(32);\n\n/**\n * # Reduce\n *\n * A fast `.reduce()` implementation.\n *\n * @param  {Array|Object} subject      The array or object to reduce over.\n * @param  {Function}     fn           The reducer function.\n * @param  {mixed}        initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}       thisContext  The context for the reducer.\n * @return {Array|Object}              The array or object containing the results.\n */\nmodule.exports = function fastReduce (subject, fn, initialValue, thisContext) {\n  if (subject instanceof Array) {\n    return reduceArray(subject, fn, initialValue, thisContext);\n  }\n  else {\n    return reduceObject(subject, fn, initialValue, thisContext);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/reduce.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/reduce.js?");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar bindInternal4 = __webpack_require__(31);\n\n/**\n * # Reduce\n *\n * A fast `.reduce()` implementation.\n *\n * @param  {Array}    subject      The array (or array-like) to reduce.\n * @param  {Function} fn           The reducer function.\n * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}   thisContext  The context for the reducer.\n * @return {mixed}                 The final result.\n */\nmodule.exports = function fastReduce (subject, fn, initialValue, thisContext) {\n  var length = subject.length,\n      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,\n      i, result;\n\n  if (initialValue === undefined) {\n    i = 1;\n    result = subject[0];\n  }\n  else {\n    i = 0;\n    result = initialValue;\n  }\n\n  for (; i < length; i++) {\n    result = iterator(result, subject[i], i, subject);\n  }\n\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/array/reduce.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/array/reduce.js?");

/***/ },
/* 31 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/**\n * Internal helper to bind a function known to have 4 arguments\n * to a given context.\n */\nmodule.exports = function bindInternal4 (func, thisContext) {\n  return function (a, b, c, d) {\n    return func.call(thisContext, a, b, c, d);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/function/bindInternal4.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/function/bindInternal4.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar bindInternal4 = __webpack_require__(31);\n\n/**\n * # Reduce\n *\n * A fast object `.reduce()` implementation.\n *\n * @param  {Object}   subject      The object to reduce over.\n * @param  {Function} fn           The reducer function.\n * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}   thisContext  The context for the reducer.\n * @return {mixed}                 The final result.\n */\nmodule.exports = function fastReduceObject (subject, fn, initialValue, thisContext) {\n  var keys = Object.keys(subject),\n      length = keys.length,\n      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,\n      i, key, result;\n\n  if (initialValue === undefined) {\n    i = 1;\n    result = subject[keys[0]];\n  }\n  else {\n    i = 0;\n    result = initialValue;\n  }\n\n  for (; i < length; i++) {\n    key = keys[i];\n    result = iterator(result, subject[key], key, subject);\n  }\n\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/fast.js/object/reduce.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/fast.js/object/reduce.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var type = __webpack_require__(34)\n\n/**\n * Returns the type of a virtual node\n *\n * @param  {Object} node\n * @return {String}\n */\n\nmodule.exports = function nodeType (node) {\n  var v = type(node)\n  if (v === 'null' || node === false) return 'empty'\n  if (v !== 'object') return 'text'\n  if (type(node.type) === 'string') return 'element'\n  return 'component'\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/node-type.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/node-type.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/**\n * toString ref.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = function(val){\n  switch (toString.call(val)) {\n    case '[object Date]': return 'date';\n    case '[object RegExp]': return 'regexp';\n    case '[object Arguments]': return 'arguments';\n    case '[object Array]': return 'array';\n    case '[object Error]': return 'error';\n  }\n\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (val !== val) return 'nan';\n  if (val && val.nodeType === 1) return 'element';\n\n  if (typeof Buffer != 'undefined' && Buffer.isBuffer(val)) return 'buffer';\n\n  val = val.valueOf\n    ? val.valueOf()\n    : Object.prototype.valueOf.apply(val)\n\n  return typeof val;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/~/component-type/index.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/~/component-type/index.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = __webpack_require__(36)\nvar ieee754 = __webpack_require__(37)\nvar isArray = __webpack_require__(38)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35).Buffer, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/index.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/buffer/index.js?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}( false ? (this.base64js = {}) : exports))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js?");

/***/ },
/* 37 */
/***/ function(module, exports) {

	eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js?");

/***/ },
/* 38 */
/***/ function(module, exports) {

	eval("\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/is-array/index.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/buffer/~/is-array/index.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("var defaults = __webpack_require__(23)\nvar nodeType = __webpack_require__(33)\nvar type = __webpack_require__(34)\n\n/**\n * Expose `stringify`.\n */\n\nmodule.exports = function (app) {\n  if (!app.element) {\n    throw new Error('No element mounted')\n  }\n\n  /**\n   * Render to string.\n   *\n   * @param {Component} component\n   * @param {Object} [props]\n   * @return {String}\n   */\n\n  function stringify (component, optProps, children) {\n    var propTypes = component.propTypes || {}\n    var props = defaults(optProps || {}, component.defaultProps || {})\n    var state = component.initialState ? component.initialState(props) : {}\n    props.children = children;\n\n    for (var name in propTypes) {\n      var options = propTypes[name]\n      if (options.source) {\n        props[name] = app.sources[options.source]\n      }\n    }\n\n    if (component.beforeMount) component.beforeMount({ props: props, state: state })\n    if (component.beforeRender) component.beforeRender({ props: props, state: state })\n    var node = component.render({ props: props, state: state })\n    return stringifyNode(node, '0')\n  }\n\n  /**\n   * Render a node to a string\n   *\n   * @param {Node} node\n   * @param {Tree} tree\n   *\n   * @return {String}\n   */\n\n  function stringifyNode (node, path) {\n    switch (nodeType(node)) {\n      case 'empty': return '<noscript />'\n      case 'text': return node\n      case 'element':\n        var children = node.children\n        var attributes = node.attributes\n        var tagName = node.type\n        var innerHTML = attributes.innerHTML\n        var str = '<' + tagName + attrs(attributes) + '>'\n\n        if (innerHTML) {\n          str += innerHTML\n        } else {\n          for (var i = 0, n = children.length; i < n; i++) {\n            str += stringifyNode(children[i], path + '.' + i)\n          }\n        }\n\n        str += '</' + tagName + '>'\n        return str\n      case 'component': return stringify(node.type, node.attributes, node.children)\n    }\n\n    throw new Error('Invalid type')\n  }\n\n  return stringifyNode(app.element, '0')\n}\n\n/**\n * HTML attributes to string.\n *\n * @param {Object} attributes\n * @return {String}\n * @api private\n */\n\nfunction attrs (attributes) {\n  var str = ''\n  for (var key in attributes) {\n    var value = attributes[key]\n    if (key === 'innerHTML') continue\n    if (isValidAttributeValue(value)) str += attr(key, attributes[key])\n  }\n  return str\n}\n\n/**\n * HTML attribute to string.\n *\n * @param {String} key\n * @param {String} val\n * @return {String}\n * @api private\n */\n\nfunction attr (key, val) {\n  return ' ' + key + '=\"' + val + '\"'\n}\n\n/**\n * Is a value able to be set a an attribute value?\n *\n * @param {Any} value\n *\n * @return {Boolean}\n */\n\nfunction isValidAttributeValue (value) {\n  var valueType = type(value)\n  switch (valueType) {\n  case 'string':\n  case 'number':\n    return true;\n\n  case 'boolean':\n    return value;\n\n  default:\n    return false;\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deku/lib/stringify.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/deku/lib/stringify.js?");

/***/ },
/* 40 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar TEAMS_STORAGE_KEY = 'upcoming-games-selected-teams';\nvar FIELDS_STORAGE_KEY = 'upcoming-games-fields';\n\nfunction createStore(dispatcher, name) {\n  var store = {\n    subscribers: [],\n    dispatch: function dispatch(payload) {\n      var newState = dispatcher(store.state, payload);\n      if (newState !== store.state) {\n        store.state = newState;\n        store.notify(newState);\n      }\n    },\n    subscribe: function subscribe(listener) {\n      store.subscribers.push(listener);\n    },\n    notify: function notify(state) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = store.subscribers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var subscriber = _step.value;\n\n          subscriber(state);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    plugin: function plugin(app) {\n      app.set(name, store.state);\n      store.subscribe(function (data) {\n        app.set(name, data);\n      });\n    }\n  };\n  store.dispatch({ type: 'INIT' });\n  return store;\n}\n\nfunction loadJSON(key, notFound) {\n  try {\n    return JSON.parse(localStorage.getItem(key)) || [];\n  } catch (error) {\n    return notFound;\n  }\n}\n\nfunction teams(state, action) {\n  if (state === undefined) state = null;\n\n  if (state === null) {\n    state = loadJSON(TEAMS_STORAGE_KEY, []);\n  }\n  switch (action.type) {\n    case 'SELECT':\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = state[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var team = _step2.value;\n\n          if (team.id === action.team.id && team.eventId === action.team.eventId) {\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return [action.team].concat(state);\n    case 'REMOVE':\n      var newState = state.filter(function (team) {\n        return !(team.id === action.team.id && team.eventId === action.team.eventId);\n      });\n      return newState.length < state.length ? newState : state;\n    case 'INIT':\n      return state;\n  }\n}\n\nvar teamStore = createStore(teams, 'teams');\nexports.teamStore = teamStore;\nteamStore.subscribe(function (teams) {\n  localStorage.setItem(TEAMS_STORAGE_KEY, JSON.stringify(teams));\n});\n\nfunction games(state, action) {\n  if (state === undefined) state = null;\n\n  switch (action.type) {\n    case 'SET':\n      return action.games;\n    case 'INIT':\n      return [];\n  }\n}\n\nvar gameStore = createStore(games, 'games');\nexports.gameStore = gameStore;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./stores.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./stores.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.loadGames = loadGames;\nexports.showEvents = showEvents;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _stores = __webpack_require__(40);\n\nvar EVENTS_URL = 'https://mods.usetopscore.com/api/events';\nvar TEAMS_URL = 'https://mods.usetopscore.com/api/teams';\nvar GAMES_URL = 'https://mods.usetopscore.com/api/games?order_by=start_date%20desc&min_date=2015-10-29';\nvar FIELDS_URL = 'https://mods.usetopscore.com/api/fields';\n\n_stores.teamStore.subscribe(function (teams) {\n  loadGames();\n});\n\nfunction loadGames() {\n  upcomingGames.apply(undefined, _toConsumableArray(_stores.teamStore.state)).then(function (games) {\n    _stores.gameStore.dispatch({ type: 'SET', games: games });\n  });\n}\n\nfunction as_json(response) {\n  return response.json();\n}\n\nfunction sorted(things) {\n  things.sort(function (a, b) {\n    return a.name > b.name ? 1 : -1;\n  });\n  return things;\n}\n\nfunction currentEvents() {\n  return fetch(EVENTS_URL).then(as_json).then(function (response) {\n    return sorted(Object.keys(response.result).map(function (eventId) {\n      return response.result[eventId];\n    }));\n  });\n}\n\nfunction teamsForEvent(event) {\n  var url = TEAMS_URL + ('?event_id=' + event.id);\n  return fetch(url).then(as_json).then(function (response) {\n    var perPage = Object.keys(response.result).length;\n    var count = response.count;\n    var pages = count === 0 ? 0 : Math.ceil(count / perPage);\n    var teamRequests = [response];\n    for (var i = 1; i < pages; i++) {\n      teamRequests.push(fetch(url + ('&page=' + (i + 1))).then(as_json));\n    }\n    return Promise.all(teamRequests).then(function (teamData) {\n      var teams = sorted(teamData.reduce(function (all, response) {\n        var teams = response.result;\n        return all.concat(Object.keys(teams).map(function (id) {\n          return teams[id];\n        }));\n      }, []));\n      teams.forEach(function (team) {\n        team.eventId = event.id;\n        team.event = event;\n      });\n      return teams;\n    });\n  });\n}\n\nfunction upcomingGames() {\n  for (var _len = arguments.length, teams = Array(_len), _key = 0; _key < _len; _key++) {\n    teams[_key] = arguments[_key];\n  }\n\n  if (teams.length === 0) return new Promise(function (resolve) {\n    return resolve([]);\n  });\n  var url = GAMES_URL + teams.map(function (team) {\n    return '&team_id[]=' + team.id;\n  }).join('');\n  return fetch(url).then(as_json).then(function (response) {\n    return response.result;\n  });\n}\n\nfunction fieldInfo(eventId, fieldId) {\n  var url = FIELDS_URL + ('?event_id=' + eventId);\n  return fetch(url).then(as_json).then(function (response) {\n    return response.result[fieldId];\n  });\n}\n\nfunction createSelect(_ref) {\n  var id = _ref.id;\n  var options = _ref.options;\n  var changeHandler = _ref.changeHandler;\n  var selectedValue = _ref.selectedValue;\n\n  var oldSelect = document.getElementById(id);\n  var select = document.createElement('select');\n  if (oldSelect) {\n    document.body.insertBefore(select, oldSelect);\n    document.body.removeChild(oldSelect);\n  } else {\n    document.body.appendChild(select);\n  }\n  select.id = id;\n  select.addEventListener('change', changeHandler);\n  var option = document.createElement('option');\n  option.disabled = true;\n  option.selected = true;\n  option.textContent = 'Please choose';\n  select.appendChild(option);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var result = _step.value;\n\n      var _option = document.createElement('option');\n      _option.value = result.id;\n      _option.textContent = result.name;\n      if (_option.value === selectedValue) {\n        _option.selected = true;\n      }\n      select.appendChild(_option);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return select;\n}\n\nfunction showEvents() {\n  currentEvents().then(function (events) {\n    var label = document.createElement('label');\n    label.textContent = 'Add a team: ';\n    document.body.appendChild(label);\n    createSelect({\n      id: 'event-selector',\n      options: events,\n      changeHandler: function changeHandler(e) {\n        var eventId = parseInt(e.target.value, 10);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = events[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _event = _step2.value;\n\n            if (_event.id === eventId) {\n              showTeamsFor(_event);\n              return;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n              _iterator2['return']();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    });\n  });\n}\n\nfunction showTeamsFor(event) {\n  teamsForEvent(event).then(function (teams) {\n    var select = createSelect({\n      id: 'team-selector',\n      options: teams,\n      changeHandler: function changeHandler(e) {\n        var teamId = parseInt(e.target.value, 10);\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = teams[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var team = _step3.value;\n\n            if (team.id === teamId) {\n              _stores.teamStore.dispatch({ type: 'SELECT', team: team });\n              return;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n              _iterator3['return']();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    });\n  });\n}\n\nfunction nextGameFor(_ref2) {\n  var id = _ref2.id;\n  var eventId = _ref2.eventId;\n\n  upcomingGamesForTeam(id).then(function (games) {\n    return games[0];\n  });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./upcoming-games.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./upcoming-games.js?");

/***/ }
/******/ ]);